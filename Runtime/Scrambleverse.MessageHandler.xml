<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Scrambleverse.MessageHandler</name>
    </assembly>
    <members>
        <member name="T:Scrambleverse.MessageHandler.IMessageProvider">
            <summary>
            Provides an interface for sending and receiving messages through various communication protocols.
            This interface abstracts the underlying message transport mechanism (e.g., WebSocket, TCP, named pipes).
            </summary>
        </member>
        <member name="E:Scrambleverse.MessageHandler.IMessageProvider.OnMessageReceived">
            <summary>
            Occurs when a message is received from the underlying transport.
            Subscribers should handle this event to process incoming messages asynchronously.
            </summary>
        </member>
        <member name="M:Scrambleverse.MessageHandler.IMessageProvider.NextMessage(System.Nullable{System.ArraySegment{System.Byte}},System.Nullable{System.Threading.CancellationToken})">
            <summary>
            Receives the next message from the underlying transport.
            This method blocks until a message is available or the connection is closed.
            </summary>
            <param name="buffer">
            Optional buffer to use for receiving data. If not provided, a default buffer will be allocated.
            The buffer should be large enough to accommodate the expected message size.
            </param>
            <param name="cancellationToken">
            Optional cancellation token to cancel the operation. If not provided, the operation will not be cancellable.
            </param>
            <returns>
            A task that represents the asynchronous receive operation.
            The task result is <c>true</c> if a message was received successfully,
            or <c>false</c> if the connection was closed or no more messages are available.
            </returns>
            <exception cref="T:System.OperationCanceledException">
            Thrown when the operation is cancelled via the cancellation token.
            </exception>
        </member>
        <member name="M:Scrambleverse.MessageHandler.IMessageProvider.Run(System.Nullable{System.ArraySegment{System.Byte}},System.Nullable{System.Threading.CancellationToken})">
            <summary>
            Continuously processes incoming messages until the connection is closed or an error occurs.
            This method will repeatedly call <see cref="M:Scrambleverse.MessageHandler.IMessageProvider.NextMessage(System.Nullable{System.ArraySegment{System.Byte}},System.Nullable{System.Threading.CancellationToken})"/> and raise the <see cref="E:Scrambleverse.MessageHandler.IMessageProvider.OnMessageReceived"/> event
            for each received message.
            </summary>
            <param name="buffer">
            Optional buffer to use for receiving data. If not provided, a default buffer will be allocated.
            This buffer will be reused for all message receives during the run loop.
            </param>
            <param name="cancellationToken">
            Optional cancellation token to cancel the operation. If not provided, the operation will continue
            until the connection is naturally closed.
            </param>
            <returns>
            A task that represents the asynchronous run operation. The task completes when the connection
            is closed, an error occurs, or the operation is cancelled.
            </returns>
            <exception cref="T:System.OperationCanceledException">
            Thrown when the operation is cancelled via the cancellation token.
            </exception>
        </member>
        <member name="M:Scrambleverse.MessageHandler.IMessageProvider.SendMessage(System.String,System.Nullable{System.Threading.CancellationToken})">
            <summary>
            Sends a message through the underlying transport.
            The message will be encoded and transmitted according to the transport protocol.
            </summary>
            <param name="message">
            The message content to send. This should be a well-formed message according to the
            expected protocol (e.g., JSON for API communication).
            </param>
            <param name="cancellationToken">
            Optional cancellation token to cancel the send operation. If not provided, the operation
            will not be cancellable.
            </param>
            <returns>
            A task that represents the asynchronous send operation. The task completes when the message
            has been successfully transmitted or an error occurs.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            Thrown when <paramref name="message"/> is null.
            </exception>
            <exception cref="T:System.OperationCanceledException">
            Thrown when the operation is cancelled via the cancellation token.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the connection is not in a valid state for sending messages.
            </exception>
        </member>
        <member name="T:Scrambleverse.MessageHandler.InvocationHandlerAttribute">
             <summary>
             Marks a method as an invocation handler that can be called remotely through the message handler system.
             This attribute specifies the name that remote callers use to invoke the associated method.
             </summary>
             <remarks>
             <para>
             Methods decorated with this attribute will be automatically registered in the <see cref="T:Scrambleverse.MessageHandler.MessageHandler"/>
             and can be invoked by remote clients by sending invoke messages with the specified name.
             </para>
             <para>
             The method can accept zero or one parameter and can return void, a value, or a Task for asynchronous operations.
             Methods must be accessible to the MessageHandler instance (public, protected, or private).
             </para>
             <example>
             <code>
             [InvocationHandler("ProcessData")]
             public void ProcessData(string data)
             {
                 // Process the data
             }
            
             [InvocationHandler("GetUserAsync")]
             public async Task&lt;User&gt; GetUserAsync(string userId)
             {
                 return await userService.GetUserAsync(userId);
             }
             </code>
             </example>
             </remarks>
        </member>
        <member name="M:Scrambleverse.MessageHandler.InvocationHandlerAttribute.#ctor(System.String)">
             <summary>
             Marks a method as an invocation handler that can be called remotely through the message handler system.
             This attribute specifies the name that remote callers use to invoke the associated method.
             </summary>
             <remarks>
             <para>
             Methods decorated with this attribute will be automatically registered in the <see cref="T:Scrambleverse.MessageHandler.MessageHandler"/>
             and can be invoked by remote clients by sending invoke messages with the specified name.
             </para>
             <para>
             The method can accept zero or one parameter and can return void, a value, or a Task for asynchronous operations.
             Methods must be accessible to the MessageHandler instance (public, protected, or private).
             </para>
             <example>
             <code>
             [InvocationHandler("ProcessData")]
             public void ProcessData(string data)
             {
                 // Process the data
             }
            
             [InvocationHandler("GetUserAsync")]
             public async Task&lt;User&gt; GetUserAsync(string userId)
             {
                 return await userService.GetUserAsync(userId);
             }
             </code>
             </example>
             </remarks>
        </member>
        <member name="P:Scrambleverse.MessageHandler.InvocationHandlerAttribute.Name">
            <summary>
            Gets the name that remote callers use to invoke this handler.
            This name is used in the "name" field of invoke messages sent through the message provider.
            </summary>
            <value>
            The invocation name for this handler. This should be unique within the message handler instance
            and follow a consistent naming convention for the application.
            </value>
        </member>
        <member name="T:Scrambleverse.MessageHandler.InvocationHandlerInfo">
            <summary>
            Encapsulates information about a method that can be invoked remotely through the message handler system.
            This class provides metadata about the method signature and handles the actual method invocation.
            </summary>
            <remarks>
            <para>
            This class is used internally by <see cref="T:Scrambleverse.MessageHandler.MessageHandler"/> to store information about methods
            decorated with <see cref="T:Scrambleverse.MessageHandler.InvocationHandlerAttribute"/>. It provides a unified interface for
            invoking methods with different signatures and handling both synchronous and asynchronous results.
            </para>
            <para>
            Supported method signatures:
            <list type="bullet">
            <item><description>Methods with no parameters: <c>void Method()</c> or <c>T Method()</c></description></item>
            <item><description>Methods with one parameter: <c>void Method(T param)</c> or <c>U Method(T param)</c></description></item>
            <item><description>Async methods: <c>Task Method()</c>, <c>Task&lt;T&gt; Method()</c>, etc.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:Scrambleverse.MessageHandler.InvocationHandlerInfo.MethodInfo">
            <summary>
            Gets the <see cref="P:Scrambleverse.MessageHandler.InvocationHandlerInfo.MethodInfo"/> representing the method that can be invoked.
            </summary>
            <value>
            The method information containing details about the method signature, parameters, and return type.
            </value>
        </member>
        <member name="P:Scrambleverse.MessageHandler.InvocationHandlerInfo.BodyType">
            <summary>
            Gets the type of the parameter that the method expects, or null if the method takes no parameters.
            </summary>
            <value>
            The parameter type for single-parameter methods, or null for parameterless methods.
            This is used for deserializing incoming message bodies to the correct type.
            </value>
        </member>
        <member name="P:Scrambleverse.MessageHandler.InvocationHandlerInfo.Object">
            <summary>
            Gets the object instance on which the method will be invoked.
            </summary>
            <value>
            The target object for method invocation. This is typically the MessageHandler instance
            that contains the decorated method.
            </value>
        </member>
        <member name="M:Scrambleverse.MessageHandler.InvocationHandlerInfo.#ctor(System.Object,System.Reflection.MethodInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:Scrambleverse.MessageHandler.InvocationHandlerInfo"/> class with the specified object and method.
            </summary>
            <param name="obj">
            The object instance on which the method will be invoked.
            </param>
            <param name="methodInfo">
            The <see cref="P:Scrambleverse.MessageHandler.InvocationHandlerInfo.MethodInfo"/> representing the method to be invoked.
            </param>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the method has more than one parameter, which is not supported.
            </exception>
            <remarks>
            During construction, this class analyzes the method signature to determine the body type
            for parameter deserialization. Methods with zero parameters will have a null body type,
            while methods with one parameter will have the parameter type as the body type.
            </remarks>
        </member>
        <member name="M:Scrambleverse.MessageHandler.InvocationHandlerInfo.Invoke(System.Object)">
            <summary>
            Invokes the method with the specified body parameter and returns the result.
            </summary>
            <param name="body">
            The parameter value to pass to the method, or null for parameterless methods.
            This should match the type specified by <see cref="P:Scrambleverse.MessageHandler.InvocationHandlerInfo.BodyType"/>.
            </param>
            <returns>
            A task that represents the asynchronous method invocation. The task result contains
            the return value of the method, or null for void methods. For async methods,
            this automatically awaits the result.
            </returns>
            <remarks>
            This method handles both synchronous and asynchronous method invocations automatically.
            For methods that return Task or Task&lt;T&gt;, the result will be awaited before returning.
            For void methods, the result will be null.
            </remarks>
            <exception cref="T:System.Reflection.TargetException">
            Thrown when the method invocation fails due to invalid target or parameters.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown when the body parameter doesn't match the expected type.
            </exception>
        </member>
        <member name="T:Scrambleverse.MessageHandler.MessageHandler">
             <summary>
             Provides a message-based communication system that enables remote procedure calls (RPC) through various transport protocols.
             This class handles both outgoing invocations to remote endpoints and incoming invocations from remote clients.
             </summary>
             <remarks>
             <para>
             The MessageHandler automatically discovers and registers methods marked with <see cref="T:Scrambleverse.MessageHandler.InvocationHandlerAttribute"/>
             as remotely callable handlers. These handlers can be invoked by remote clients by sending appropriately formatted
             invoke messages through the underlying <see cref="T:Scrambleverse.MessageHandler.IMessageProvider"/>.
             </para>
             <para>
             The class supports both synchronous and asynchronous operations, automatically handling the serialization and
             deserialization of message payloads using System.Text.Json.
             </para>
             <para>
             Message format follows a JSON structure with the following types:
             <list type="bullet">
             <item><description><c>invoke</c> - Requests execution of a remote handler</description></item>
             <item><description><c>result</c> - Returns the result of a successful invocation</description></item>
             <item><description><c>error</c> - Returns error information when an invocation fails</description></item>
             </list>
             </para>
             </remarks>
             <example>
             <code>
             // Define a message handler with remote callable methods
             public class MyMessageHandler : MessageHandler
             {
                 public MyMessageHandler(IMessageProvider provider) : base(provider) { }
            
                 [InvocationHandler("ProcessAsync")]
                 public async Task&lt;string&gt; ProcessDataAsync(string input)
                 {
                     await Task.Delay(100);
                     return $"Processed: {input}";
                 }
             }
            
             // Alternative: Use separate handler object
             public class DataProcessor
             {
                 [InvocationHandler("ProcessData")]
                 public string ProcessData(string input) => $"Processed: {input}";
             }
            
             // Usage
             var handler = new MyMessageHandler(messageProvider);
             // or with separate handler object:
             var processor = new DataProcessor();
             var handlerWithSeparateObject = new MessageHandler(messageProvider, processor);
            
             // Call remote handler
             var result = await handler.Invoke&lt;int, (int, int)&gt;("RemoteCalculate", (5, 3));
             </code>
             </example>
        </member>
        <member name="M:Scrambleverse.MessageHandler.MessageHandler.#ctor(Scrambleverse.MessageHandler.IMessageProvider,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Scrambleverse.MessageHandler.MessageHandler"/> class with the specified message provider and optional handler object.
            </summary>
            <param name="messageProvider">
            The message provider that handles the underlying communication transport.
            This provider will be used for both sending outgoing messages and receiving incoming messages.
            </param>
            <param name="handler">
            An optional handler object that contains methods decorated with <see cref="T:Scrambleverse.MessageHandler.InvocationHandlerAttribute"/>.
            If null, the current instance will be used as the handler object.
            </param>
            <remarks>
            <para>
            During construction, the handler automatically scans the target object's type for methods decorated with
            <see cref="T:Scrambleverse.MessageHandler.InvocationHandlerAttribute"/> and registers them as remotely callable handlers.
            The method invocations will be performed on the specified <paramref name="handler"/> object,
            or on the current instance if no handler is provided.
            </para>
            <para>
            The message provider's <see cref="E:Scrambleverse.MessageHandler.IMessageProvider.OnMessageReceived"/> event is subscribed to
            for processing incoming messages.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown when <paramref name="messageProvider"/> is null.
            </exception>
        </member>
        <member name="M:Scrambleverse.MessageHandler.MessageHandler.HandleMessage(System.String)">
            <summary>
            Handles incoming messages from the message provider.
            This method is automatically called when the message provider receives a message.
            </summary>
            <param name="message">
            The raw message content as a JSON string. Expected to contain a "type" field
            indicating the message type ("result", "invoke", or "error").
            </param>
            <returns>
            A task representing the asynchronous message processing operation.
            </returns>
        </member>
        <member name="M:Scrambleverse.MessageHandler.MessageHandler.Invoke``2(System.String,``1)">
             <summary>
             Invokes a remote handler and waits for the result.
             </summary>
             <typeparam name="T">
             The expected return type of the remote handler.
             </typeparam>
             <typeparam name="U">
             The type of the message body to send to the remote handler.
             </typeparam>
             <param name="target">
             The name of the remote handler to invoke. This should match the name specified
             in the <see cref="T:Scrambleverse.MessageHandler.InvocationHandlerAttribute"/> on the remote endpoint.
             </param>
             <param name="message">
             The message body to send to the remote handler. This will be serialized to JSON
             and included in the invoke message.
             </param>
             <returns>
             A task that represents the asynchronous invoke operation. The task result contains
             the deserialized response from the remote handler.
             </returns>
             <exception cref="T:System.ArgumentNullException">
             Thrown when <paramref name="target"/> is null.
             </exception>
             <exception cref="T:System.Exception">
             Thrown when the remote handler returns an error or when no response is received.
             </exception>
             <example>
             <code>
             // Invoke a remote calculator
             var result = await handler.Invoke&lt;int, (int, int)&gt;("Calculate", (5, 3));
            
             // Invoke a remote data processor
             var processed = await handler.Invoke&lt;string, string&gt;("ProcessData", "input data");
             </code>
             </example>
        </member>
        <member name="M:Scrambleverse.MessageHandler.MessageHandler.ProcessInvocation(System.Text.Json.Nodes.JsonNode)">
            <summary>
            Processes an incoming invocation request and executes the corresponding local handler.
            </summary>
            <param name="node">
            The parsed JSON node containing the invocation request. Expected to have
            "name", "id", and optionally "body" fields.
            </param>
            <returns>
            A task representing the asynchronous processing operation.
            </returns>
            <remarks>
            This method looks up the handler by name, deserializes the message body if present,
            executes the handler, and sends either a result or error response back through
            the message provider.
            </remarks>
        </member>
        <member name="M:Scrambleverse.MessageHandler.MessageHandler.ProcessResult(System.Text.Json.Nodes.JsonNode)">
            <summary>
            Processes an incoming result message and completes the corresponding pending invocation.
            </summary>
            <param name="node">
            The parsed JSON node containing the result message. Expected to have
            "id" and "body" fields.
            </param>
            <remarks>
            This method matches the result with a pending invocation by ID, deserializes the result,
            and completes the associated TaskCompletionSource to unblock the waiting Invoke call.
            </remarks>
            <exception cref="T:System.Exception">
            Thrown when the result message is missing an ID or when no pending invocation
            is found for the given ID.
            </exception>
        </member>
        <member name="T:Scrambleverse.MessageHandler.Reflection.Awaitable">
            <summary>
            Provides utility methods for working with awaitable objects and types through reflection.
            This class enables dynamic awaiting of objects that implement the awaitable pattern,
            regardless of their specific type.
            </summary>
            <remarks>
            <para>
            The awaitable pattern in .NET requires an object to have:
            <list type="bullet">
            <item><description>A GetAwaiter() method that returns an awaiter</description></item>
            <item><description>The awaiter must have an IsCompleted property</description></item>
            <item><description>The awaiter must have OnCompleted(Action) or UnsafeOnCompleted(Action) method</description></item>
            <item><description>The awaiter must have a GetResult() method</description></item>
            </list>
            </para>
            <para>
            This class provides reflection-based utilities to work with such objects dynamically,
            allowing code to await objects without knowing their compile-time type.
            </para>
            </remarks>
        </member>
        <member name="M:Scrambleverse.MessageHandler.Reflection.Awaitable.AwaitIfAwaitable(System.Object)">
             <summary>
             Awaits an object if it implements the awaitable pattern, otherwise returns the object as-is.
             </summary>
             <param name="obj">
             The object to potentially await. Can be any object, including null, awaitable types
             (Task, ValueTask, custom awaitables), or non-awaitable types.
             </param>
             <returns>
             A task representing the asynchronous operation. The task result is:
             <list type="bullet">
             <item><description>null if the input object is null</description></item>
             <item><description>The awaited result if the object is awaitable</description></item>
             <item><description>The original object if it's not awaitable</description></item>
             </list>
             </returns>
             <remarks>
             <para>
             This method uses reflection to determine if an object implements the awaitable pattern.
             If the object is awaitable, it will be dynamically awaited and the result returned.
             If the object is not awaitable, it is returned unchanged.
             </para>
             <para>
             This is particularly useful in scenarios where you receive objects of unknown types
             that might be awaitable (such as method invocation results that could be Task&lt;T&gt; or T).
             </para>
             </remarks>
             <example>
             <code>
             // With a Task
             var task = Task.FromResult(42);
             var result = await task.AwaitIfAwaitable(); // Returns 42
            
             // With a non-awaitable object
             var value = "Hello";
             var result = await value.AwaitIfAwaitable(); // Returns "Hello"
            
             // With null
             object nullObj = null;
             var result = await nullObj.AwaitIfAwaitable(); // Returns null
             </code>
             </example>
             <exception cref="T:System.InvalidOperationException">
             Thrown when the object appears to be awaitable but GetAwaiter() returns null.
             </exception>
        </member>
        <member name="M:Scrambleverse.MessageHandler.Reflection.Awaitable.GetAwaitedResult(System.Type,System.Type@)">
             <summary>
             Determines if a type implements the awaitable pattern and extracts the awaited result type.
             </summary>
             <param name="type">
             The type to examine for the awaitable pattern.
             </param>
             <param name="awaitedResultType">
             When this method returns true, contains the type that would be returned when awaiting
             an instance of the input type. When this method returns false, this parameter is undefined.
             </param>
             <returns>
             true if the type implements the awaitable pattern; otherwise, false.
             </returns>
             <remarks>
             <para>
             This method checks if a type follows the awaitable pattern by verifying:
             <list type="number">
             <item><description>The type has a parameterless GetAwaiter() method</description></item>
             <item><description>The awaiter type has an IsCompleted property of type bool</description></item>
             <item><description>The awaiter type has either OnCompleted(Action) or UnsafeOnCompleted(Action) method</description></item>
             <item><description>The awaiter type has a GetResult() method</description></item>
             </list>
             </para>
             <para>
             For standard .NET types:
             <list type="bullet">
             <item><description>Task returns typeof(void)</description></item>
             <item><description>Task&lt;T&gt; returns typeof(T)</description></item>
             <item><description>ValueTask returns typeof(void)</description></item>
             <item><description>ValueTask&lt;T&gt; returns typeof(T)</description></item>
             </list>
             </para>
             </remarks>
             <example>
             <code>
             // Check Task&lt;int&gt;
             if (typeof(Task&lt;int&gt;).GetAwaitedResult(out var resultType))
             {
                 Console.WriteLine(resultType); // Prints: System.Int32
             }
            
             // Check non-awaitable type
             if (typeof(string).GetAwaitedResult(out var stringType))
             {
                 // This block won't execute
             }
             else
             {
                 Console.WriteLine("String is not awaitable");
             }
             </code>
             </example>
        </member>
        <member name="T:Scrambleverse.MessageHandler.WebsocketMessageProvider">
             <summary>
             Provides WebSocket-based message communication implementing the <see cref="T:Scrambleverse.MessageHandler.IMessageProvider"/> interface.
             This class enables real-time, bidirectional communication through WebSocket connections.
             </summary>
             <remarks>
             <para>
             The WebsocketMessageProvider can work with any WebSocket implementation, including client and server connections.
             It handles message framing, text encoding/decoding, and connection lifecycle management.
             </para>
             <para>
             Messages are automatically encoded as UTF-8 text when sending and decoded when receiving.
             The provider supports both single-frame and multi-frame WebSocket messages.
             </para>
             <para>
             Connection management can be configured through the autoClose parameter. When autoClose is true,
             the underlying WebSocket will be disposed when this provider is disposed.
             </para>
             </remarks>
             <example>
             <code>
             // Connect to a WebSocket server
             var provider = await WebsocketMessageProvider.Connect("ws://localhost:8080/api");
            
             // Use with existing WebSocket
             var webSocket = new ClientWebSocket();
             await webSocket.ConnectAsync(new Uri("ws://example.com"), CancellationToken.None);
             var provider = new WebsocketMessageProvider(webSocket, autoClose: true);
            
             // Handle messages
             provider.OnMessageReceived += async (message) => {
                 Console.WriteLine($"Received: {message}");
             };
            
             // Send messages
             await provider.SendMessage("Hello, WebSocket!");
            
             // Run message loop
             await provider.Run();
             </code>
             </example>
        </member>
        <member name="M:Scrambleverse.MessageHandler.WebsocketMessageProvider.#ctor(System.Net.WebSockets.WebSocket,System.Boolean)">
             <summary>
             Provides WebSocket-based message communication implementing the <see cref="T:Scrambleverse.MessageHandler.IMessageProvider"/> interface.
             This class enables real-time, bidirectional communication through WebSocket connections.
             </summary>
             <remarks>
             <para>
             The WebsocketMessageProvider can work with any WebSocket implementation, including client and server connections.
             It handles message framing, text encoding/decoding, and connection lifecycle management.
             </para>
             <para>
             Messages are automatically encoded as UTF-8 text when sending and decoded when receiving.
             The provider supports both single-frame and multi-frame WebSocket messages.
             </para>
             <para>
             Connection management can be configured through the autoClose parameter. When autoClose is true,
             the underlying WebSocket will be disposed when this provider is disposed.
             </para>
             </remarks>
             <example>
             <code>
             // Connect to a WebSocket server
             var provider = await WebsocketMessageProvider.Connect("ws://localhost:8080/api");
            
             // Use with existing WebSocket
             var webSocket = new ClientWebSocket();
             await webSocket.ConnectAsync(new Uri("ws://example.com"), CancellationToken.None);
             var provider = new WebsocketMessageProvider(webSocket, autoClose: true);
            
             // Handle messages
             provider.OnMessageReceived += async (message) => {
                 Console.WriteLine($"Received: {message}");
             };
            
             // Send messages
             await provider.SendMessage("Hello, WebSocket!");
            
             // Run message loop
             await provider.Run();
             </code>
             </example>
        </member>
        <member name="M:Scrambleverse.MessageHandler.WebsocketMessageProvider.Connect(System.String,System.Nullable{System.Threading.CancellationToken})">
            <summary>
            Creates a new WebSocket connection to the specified URI and returns a WebsocketMessageProvider instance.
            </summary>
            <param name="uri">
            The WebSocket URI to connect to. Should use "ws://" or "wss://" scheme.
            </param>
            <param name="cancellationToken">
            Optional cancellation token to cancel the connection attempt.
            </param>
            <returns>
            A task that represents the asynchronous connect operation. The task result is a
            WebsocketMessageProvider instance with autoClose set to true.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            Thrown when <paramref name="uri"/> is null.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown when <paramref name="uri"/> is not a valid WebSocket URI.
            </exception>
            <exception cref="T:System.Net.WebSockets.WebSocketException">
            Thrown when the WebSocket connection fails.
            </exception>
            <exception cref="T:System.OperationCanceledException">
            Thrown when the operation is cancelled via the cancellation token.
            </exception>
        </member>
        <member name="M:Scrambleverse.MessageHandler.WebsocketMessageProvider.Connect(System.Uri,System.Nullable{System.Threading.CancellationToken})">
            <summary>
            Creates a new WebSocket connection to the specified URI and returns a WebsocketMessageProvider instance.
            </summary>
            <param name="uri">
            The WebSocket URI to connect to. Should use "ws://" or "wss://" scheme.
            </param>
            <param name="cancellationToken">
            Optional cancellation token to cancel the connection attempt.
            </param>
            <returns>
            A task that represents the asynchronous connect operation. The task result is a
            WebsocketMessageProvider instance with autoClose set to true.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            Thrown when <paramref name="uri"/> is null.
            </exception>
            <exception cref="T:System.Net.WebSockets.WebSocketException">
            Thrown when the WebSocket connection fails.
            </exception>
            <exception cref="T:System.OperationCanceledException">
            Thrown when the operation is cancelled via the cancellation token.
            </exception>
        </member>
        <member name="M:Scrambleverse.MessageHandler.WebsocketMessageProvider.Dispose">
            <summary>
            Releases all resources used by the WebsocketMessageProvider.
            </summary>
            <remarks>
            If autoClose was set to true during construction, this method will also dispose
            the underlying WebSocket. Otherwise, the WebSocket remains open and must be
            managed separately.
            </remarks>
        </member>
        <member name="M:Scrambleverse.MessageHandler.WebsocketMessageProvider.NextMessage(System.Nullable{System.ArraySegment{System.Byte}},System.Nullable{System.Threading.CancellationToken})">
            <inheritdoc />
            <remarks>
            This implementation handles WebSocket message framing automatically. Multi-frame messages
            are assembled into a single message before triggering the OnMessageReceived event.
            Close messages are handled by closing the WebSocket connection gracefully.
            </remarks>
        </member>
        <member name="E:Scrambleverse.MessageHandler.WebsocketMessageProvider.OnMessageReceived">
            <inheritdoc />
            <remarks>
            This event is raised when a complete text message is received from the WebSocket.
            The message content is automatically decoded from UTF-8 bytes to a string.
            </remarks>
        </member>
        <member name="M:Scrambleverse.MessageHandler.WebsocketMessageProvider.SendMessage(System.String,System.Nullable{System.Threading.CancellationToken})">
            <inheritdoc />
            <remarks>
            Messages are encoded as UTF-8 and sent as WebSocket text frames. Each call to this method
            sends a complete message in a single frame with the EndOfMessage flag set to true.
            </remarks>
        </member>
        <member name="M:Scrambleverse.MessageHandler.WebsocketMessageProvider.Run(System.Nullable{System.ArraySegment{System.Byte}},System.Nullable{System.Threading.CancellationToken})">
            <inheritdoc />
            <remarks>
            This method continuously calls <see cref="M:Scrambleverse.MessageHandler.WebsocketMessageProvider.NextMessage(System.Nullable{System.ArraySegment{System.Byte}},System.Nullable{System.Threading.CancellationToken})"/> while the WebSocket connection
            remains open. It will exit when the connection is closed, an error occurs, or the
            operation is cancelled.
            </remarks>
        </member>
    </members>
</doc>
